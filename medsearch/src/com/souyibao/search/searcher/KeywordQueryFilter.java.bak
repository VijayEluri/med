package com.souyibao.search.searcher;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.lucene.index.Term;
import org.apache.lucene.search.BooleanClause;
import org.apache.lucene.search.BooleanQuery;
import org.apache.lucene.search.PhraseQuery;

import com.souyibao.search.module.Module;
import com.souyibao.search.module.ModuleFactory;
import com.souyibao.search.module.ModuleField;
import com.souyibao.search.util.QueryGenerator;
import com.souyibao.shared.KeywordManager;

public class KeywordQueryFilter extends BasicQueryFilter{
	private static final Log LOG = LogFactory
			.getLog("com.souyibao.search.searcher.KeywordQueryFilter");
	
	private Collection<String> allQueryClauses = null;
	public KeywordQueryFilter() {
		allQueryClauses = new ArrayList<String>();
	}
	
	@Override
	public BooleanQuery filter(String module, String queryString,
			BooleanQuery output) {
		String[] clauses = parseQueryString(queryString);		
		if (clauses == null) {
			return output;
		}
				
		Module medModule = ModuleFactory.getInstance().getModule(module);
		if (medModule == null) {
			LOG.fatal("unknown module : " + module);
			throw new RuntimeException(" unknow module : " + module);
		}
		
		Collection<ModuleField> fields = medModule.getFields();
		
		for (int i = 0; i < clauses.length; i++) {
			// try to find the keyword for the clause
			String clause = clauses[i];
			Collection<String> keywordNames = KeywordManager.getInstance()
					.getAllKeywordNames(clause);
			if ((keywordNames == null) || (keywordNames.isEmpty())) {
				// the clause isn't one keyword, needs to the clause as
				// term query and phrase query
				String[] allTerms = QueryGenerator.parseQueryString(clause);
				addTerms(allTerms, fields, output);
				// TODO: the phrase query clause won't work in CJK enviorment
				// reason: our analizer index the chinese character one by one
				// check the class com.souyibao.shared.analysis.MedAnalyzer
//				addSloppyPhrases(clause, fields, output);
			} else {			
				// keyword, only need to add the phrase query				
				addKeywordPhrase(keywordNames, fields, output);
			}
		} 
		
		return output;
	}
	
	private void addKeywordPhrase(Collection<String> keywordNames,
			Collection<ModuleField> fields, BooleanQuery output) {
		for (Iterator<String> iterator = keywordNames.iterator(); iterator
				.hasNext();) {
			String phrase = iterator.next();
			if (needPhraseQuery(phrase)) {
				String[] allTerms = QueryGenerator.parseQueryString(phrase);
				
				for (Iterator<ModuleField> fieldIte = fields.iterator(); fieldIte
						.hasNext();) {
					ModuleField field = fieldIte.next();					
					BooleanQuery query = new BooleanQuery();
					
					for (int i = 0; i < allTerms.length; i++) {
						query.add(termQuery(new Term(field.getName(), allTerms[i]),
								field.getBoost()), BooleanClause.Occur.MUST);
					}
					
					output.add(query, BooleanClause.Occur.MUST);
				}
			}
		}
	}
	
	@Override
	protected boolean needPhraseQuery(String phrase) {
		if (allQueryClauses.contains(phrase)) {
			return false;
		}
		
		allQueryClauses.add(phrase);
		return true;
	}

	@Override
	protected boolean needTermQuery(String term) {
		if (allQueryClauses.contains(term)) {
			return false;
		}
				
		allQueryClauses.add(term);
		return true;
	}

	private String[] parseQueryString(String queryString) {
//		// try to split the query string according to some stop chars
//		String[] words = null;
//		try{
//			words = queryString.split("[( )ã€€/\\\\]+");
//		} catch (Exception e) {
//			// need to log it
//			return QueryGenerator.parseQueryString(queryString);
//		}
//		
//		if (words != null) {
//			return words;
//		}
		
		return QueryGenerator.parseQueryString(queryString);
	}
}
